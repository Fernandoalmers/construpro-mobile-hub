
import { useState, useCallback, useEffect, useMemo } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { addressService, Address } from '@/services/addressService';
import { addressCacheService } from '@/services/addressCacheService';
import { toast } from '@/components/ui/use-toast';
import { useAuth } from '@/context/AuthContext';

export function useAddresses() {
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [editingAddress, setEditingAddress] = useState<Address | null>(null);
  const [errorDetails, setErrorDetails] = useState<string | null>(null);
  const [cachedAddresses, setCachedAddresses] = useState<Address[]>([]);
  const [isCacheLoaded, setIsCacheLoaded] = useState(false);
  const queryClient = useQueryClient();
  const { refreshProfile, user } = useAuth();

  // ESTABILIZADO: Carregar cache apenas uma vez
  useEffect(() => {
    if (isCacheLoaded) return;
    
    console.log('[useAddresses] üè† Carregando endere√ßos do cache para exibi√ß√£o instant√¢nea...');
    
    try {
      const cached = addressCacheService.loadFromCache();
      if (cached && cached.length > 0) {
        setCachedAddresses(cached);
        console.log('[useAddresses] ‚úÖ Endere√ßos do cache dispon√≠veis instantaneamente:', cached.length);
      } else {
        console.log('[useAddresses] ‚ÑπÔ∏è Cache vazio - aguardando servidor');
      }
    } catch (error) {
      console.warn('[useAddresses] ‚ö†Ô∏è Erro ao carregar cache:', error);
    } finally {
      setIsCacheLoaded(true);
    }
  }, [isCacheLoaded]);

  // Enhanced error formatting
  const formatErrorMessage = (error: any): string => {
    console.error("Error in addresses:", error);
    let errorMessage = 'Um erro inesperado ocorreu.';
    
    if (error instanceof Error) {
      errorMessage = error.message;
    } else if (typeof error === 'object' && error !== null) {
      errorMessage = error.message || JSON.stringify(error);
    } else if (typeof error === 'string') {
      errorMessage = error;
    }
    
    setErrorDetails(typeof error === 'object' ? JSON.stringify(error) : String(error));
    return errorMessage;
  };

  // Enhanced CEP validation
  const validateCEP = (cep: string): boolean => {
    const cleanCep = cep.replace(/\D/g, '');
    if (cleanCep.length !== 8) return false;
    if (cleanCep === '00000000' || /^(\d)\1{7}$/.test(cleanCep)) return false;
    return true;
  };

  // Enhanced address validation
  const validateAddress = (address: Address): { isValid: boolean; errors: string[] } => {
    const errors: string[] = [];
    
    if (!address.nome?.trim()) errors.push('Nome √© obrigat√≥rio');
    if (!address.cep?.trim()) {
      errors.push('CEP √© obrigat√≥rio');
    } else if (!validateCEP(address.cep)) {
      errors.push('CEP deve ter 8 d√≠gitos e ser v√°lido');
    }
    if (!address.logradouro?.trim()) errors.push('Logradouro √© obrigat√≥rio');
    if (!address.numero?.trim()) errors.push('N√∫mero √© obrigat√≥rio');
    if (!address.bairro?.trim()) errors.push('Bairro √© obrigat√≥rio');
    if (!address.cidade?.trim()) errors.push('Cidade √© obrigat√≥ria');
    if (!address.estado?.trim()) errors.push('Estado √© obrigat√≥rio');
    
    return { isValid: errors.length === 0, errors };
  };

  // ESTABILIZADO: Fetch addresses com cache mais longo
  const { 
    data: serverAddresses = [], 
    isLoading: isLoadingServer, 
    error, 
    refetch
  } = useQuery({
    queryKey: ['addresses'],
    queryFn: async () => {
      try {
        console.log("üîÑ Sincronizando endere√ßos com servidor em background...");
        
        if (!user?.id) {
          throw new Error('Usu√°rio n√£o autenticado');
        }
        
        const data = await addressService.getUserAddresses(user.id);
        
        // Salvar no cache ap√≥s sucesso
        addressCacheService.saveToCache(data);
        
        // Atualizar cache local tamb√©m
        setCachedAddresses(data);
        
        console.log("‚úÖ Endere√ßos sincronizados com sucesso:", data.length);
        setErrorDetails(null);
        return data;
      } catch (err) {
        const errorMsg = formatErrorMessage(err);
        console.error("‚ùå Erro ao sincronizar endere√ßos:", errorMsg);
        throw err;
      }
    },
    retry: 1,
    retryDelay: 2000,
    staleTime: 2 * 60 * 1000,
    gcTime: 10 * 60 * 1000,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
    enabled: isCacheLoaded && !!user?.id
  });

  // ESTABILIZADO: Priorizar dados sem mudan√ßas reativas
  const addresses = useMemo(() => {
    if (serverAddresses.length > 0) {
      return serverAddresses;
    }
    return cachedAddresses;
  }, [serverAddresses, cachedAddresses]);
  
  const isLoading = !isCacheLoaded || (cachedAddresses.length === 0 && isLoadingServer);

  // MELHORADO: Set primary address mutation com sincroniza√ß√£o completa
  const setPrimaryAddressMutation = useMutation({
    mutationFn: async (addressId: string) => {
      try {
        console.log(`[useAddresses] üè† Definindo endere√ßo ${addressId} como principal`);
        
        if (!user?.id) {
          throw new Error('Usu√°rio n√£o autenticado');
        }
        
        const currentAddresses = addresses;
        const addressToSet = currentAddresses.find(addr => addr.id === addressId);
        
        if (!addressToSet) {
          throw new Error('Endere√ßo n√£o encontrado. Atualize a p√°gina e tente novamente.');
        }
        
        // Executar a mudan√ßa no servidor
        await addressService.setPrimaryAddress(addressId, user.id);
        
        console.log(`[useAddresses] ‚úÖ Endere√ßo principal definido no servidor`);
        return { addressId, newCep: addressToSet.cep };
      } catch (err) {
        const errorMsg = formatErrorMessage(err);
        console.error("[useAddresses] ‚ùå Erro ao definir endere√ßo principal:", errorMsg);
        throw err;
      }
    },
    onSuccess: async (result) => {
      const { addressId, newCep } = result;
      console.log(`[useAddresses] üîÑ Iniciando sincroniza√ß√£o completa para endere√ßo:`, addressId);
      
      try {
        // PASSO 1: For√ßar refresh do perfil no AuthContext
        console.log(`[useAddresses] üìã For√ßando refresh do perfil no AuthContext...`);
        await refreshProfile();
        
        // PASSO 2: Aguardar um pouco para garantir sincroniza√ß√£o
        await new Promise(resolve => setTimeout(resolve, 800));
        
        // PASSO 3: Invalidar e for√ßar refetch das queries
        console.log(`[useAddresses] üóÇÔ∏è Invalidando cache e for√ßando refetch...`);
        queryClient.invalidateQueries({ queryKey: ['addresses'] });
        addressCacheService.clearCache();
        setCachedAddresses([]);
        
        // PASSO 4: Disparar evento customizado para comunica√ß√£o entre p√°ginas
        console.log(`[useAddresses] üì° Disparando evento de mudan√ßa de endere√ßo principal...`);
        window.dispatchEvent(new CustomEvent('primary-address-changed', {
          detail: { 
            newCep, 
            addressId,
            timestamp: Date.now()
          }
        }));
        
        // PASSO 5: For√ßar refetch imediato
        setTimeout(() => {
          refetch();
        }, 100);
        
        console.log(`[useAddresses] üéâ Sincroniza√ß√£o completa finalizada com sucesso`);
        
        toast({
          title: "‚úÖ Endere√ßo principal atualizado",
          description: "Endere√ßo definido como principal e sincronizado em todo o sistema.",
          duration: 3000
        });
      } catch (syncError) {
        console.error(`[useAddresses] ‚ö†Ô∏è Erro na sincroniza√ß√£o p√≥s-mudan√ßa:`, syncError);
        toast({
          variant: "destructive",
          title: "‚ö†Ô∏è Endere√ßo atualizado com aviso",
          description: "Endere√ßo foi alterado, mas pode precisar de alguns segundos para sincronizar."
        });
      }
    },
    onError: (error: any, addressId, context) => {
      console.error(`[useAddresses] ‚ùå Falha ao definir endere√ßo principal ${addressId}:`, error);
      
      const errorMsg = formatErrorMessage(error);
      toast({
        variant: "destructive",
        title: "‚ùå Erro ao definir endere√ßo principal", 
        description: errorMsg
      });
    }
  });

  // Delete address mutation
  const deleteAddressMutation = useMutation({
    mutationFn: async (addressId: string) => {
      try {
        console.log(`üóëÔ∏è Removendo endere√ßo: ${addressId}`);
        return await addressService.deleteAddress(addressId);
      } catch (err) {
        const errorMsg = formatErrorMessage(err);
        console.error("‚ùå Erro ao remover endere√ßo:", errorMsg);
        throw err;
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['addresses'], refetchType: 'none' });
      addressCacheService.clearCache();
      toast({
        title: "‚úÖ Endere√ßo removido",
        description: "Endere√ßo removido com sucesso."
      });
    },
    onError: (error: any) => {
      const errorMsg = formatErrorMessage(error);
      toast({
        variant: "destructive",
        title: "‚ùå Erro ao remover endere√ßo",
        description: errorMsg
      });
    }
  });

  // MELHORADO: Save address mutation com logs detalhados e handling aprimorado
  const saveAddressMutation = useMutation({
    mutationFn: async (data: { address: Address, isEdit: boolean }) => {
      try {
        console.log("üíæ [saveAddressMutation] Iniciando salvamento:", {
          isEdit: data.isEdit,
          addressId: data.address.id,
          nome: data.address.nome,
          cep: data.address.cep,
          userId: user?.id
        });
        
        const validation = validateAddress(data.address);
        if (!validation.isValid) {
          console.error("‚ùå [saveAddressMutation] Valida√ß√£o falhou:", validation.errors);
          throw new Error(`Dados inv√°lidos: ${validation.errors.join(', ')}`);
        }
        
        const cleanedAddress = {
          ...data.address,
          cep: data.address.cep.replace(/\D/g, ''),
          user_id: user?.id || data.address.user_id
        };
        
        console.log("üì§ [saveAddressMutation] Chamando servi√ßo com dados limpos:", cleanedAddress);
        
        let result;
        if (data.isEdit && data.address.id) {
          console.log("‚úèÔ∏è [saveAddressMutation] Editando endere√ßo existente");
          result = await addressService.updateAddress(data.address.id, cleanedAddress);
        } else {
          console.log("‚ûï [saveAddressMutation] Criando novo endere√ßo");
          result = await addressService.addAddress(cleanedAddress);
        }
        
        console.log("‚úÖ [saveAddressMutation] Resposta do servi√ßo:", result);
        return result;
      } catch (err) {
        const errorMsg = formatErrorMessage(err);
        console.error("‚ùå [saveAddressMutation] Erro ao salvar endere√ßo:", errorMsg, err);
        throw err;
      }
    },
    onSuccess: (result, variables) => {
      console.log("üéâ [saveAddressMutation] Sucesso! Resultado:", result);
      
      // Invalidar queries e limpar cache
      console.log("üóÇÔ∏è [saveAddressMutation] Invalidando queries e limpando cache...");
      queryClient.invalidateQueries({ queryKey: ['addresses'] });
      addressCacheService.clearCache();
      
      // For√ßar refetch imediato
      console.log("üîÑ [saveAddressMutation] For√ßando refetch...");
      setTimeout(() => {
        refetch();
      }, 100);
      
      setErrorDetails(null);
      toast({
        title: variables.isEdit ? "‚úÖ Endere√ßo atualizado" : "‚úÖ Endere√ßo adicionado",
        description: variables.isEdit 
          ? "Endere√ßo atualizado com sucesso." 
          : "Endere√ßo adicionado com sucesso."
      });
      setIsAddModalOpen(false);
      setEditingAddress(null);
      
      console.log("‚úÖ [saveAddressMutation] Processo de salvamento conclu√≠do com sucesso");
    },
    onError: (error: any, variables) => {
      console.error("‚ùå [saveAddressMutation] Erro na mutation:", {
        error,
        variables,
        errorMessage: error?.message,
        errorDetails: error
      });
      
      const errorMsg = formatErrorMessage(error);
      toast({
        variant: "destructive",
        title: "‚ùå Erro ao salvar endere√ßo",
        description: errorMsg
      });
    }
  });

  // Enhanced retry functionality
  const retryOperation = useCallback(async () => {
    toast({
      title: "üîÑ Tentando novamente",
      description: "Tentando carregar seus endere√ßos..."
    });
    await refetch();
  }, [refetch]);

  const handleSetDefaultAddress = (addressId: string) => {
    console.log(`[useAddresses] üè† Usu√°rio solicitou definir endere√ßo ${addressId} como principal`);
    setPrimaryAddressMutation.mutate(addressId);
  };

  const handleEditAddress = (address: Address) => {
    console.log('[useAddresses] ‚úèÔ∏è Editando endere√ßo:', address);
    setEditingAddress(address);
    setIsAddModalOpen(true);
  };

  const handleDeleteAddress = (addressId: string) => {
    if (window.confirm('Tem certeza que deseja remover este endere√ßo?')) {
      deleteAddressMutation.mutate(addressId);
    }
  };

  const handleAddAddress = () => {
    console.log('[useAddresses] ‚ûï Abrindo modal para novo endere√ßo');
    setEditingAddress(null);
    setIsAddModalOpen(true);
  };

  const handleSaveAddress = (address: Address) => {
    console.log("üíæ [useAddresses] handleSaveAddress chamado com:", address);
    const isEdit = Boolean(editingAddress);
    console.log("üîÑ [useAddresses] Disparando mutation, isEdit:", isEdit);
    saveAddressMutation.mutate({ address, isEdit });
  };

  // Enhanced addAddress function for useCheckout
  const addAddress = async (formData: Partial<Address>): Promise<Address | null> => {
    try {
      console.log("‚ûï [useAddresses] addAddress chamado com:", formData);
      
      const fullAddress: Address = {
        id: '',
        user_id: user?.id || '',
        nome: formData.nome || '',
        cep: formData.cep?.replace(/\D/g, '') || '',
        logradouro: formData.logradouro || '',
        numero: formData.numero || '',
        complemento: formData.complemento || '',
        bairro: formData.bairro || '',
        cidade: formData.cidade || '',
        estado: formData.estado || '',
        principal: formData.principal || false,
        created_at: '',
        updated_at: '',
        ...formData
      };

      const validation = validateAddress(fullAddress);
      if (!validation.isValid) {
        console.error("‚ùå [useAddresses] Valida√ß√£o falhou no addAddress:", validation.errors);
        throw new Error(`Dados inv√°lidos: ${validation.errors.join(', ')}`);
      }

      console.log("üì§ [useAddresses] Chamando addressService.addAddress...");
      const result = await addressService.addAddress(fullAddress);
      console.log("‚úÖ [useAddresses] Resultado do addAddress:", result);
      
      queryClient.invalidateQueries({ queryKey: ['addresses'] });
      addressCacheService.clearCache();
      
      return result;
    } catch (error) {
      console.error("‚ùå [useAddresses] Erro ao adicionar endere√ßo:", error);
      throw error;
    }
  };

  const getPrimaryAddress = () => {
    return addresses.find(address => address.principal);
  };

  return {
    addresses,
    isLoading,
    error,
    errorDetails,
    refetch: retryOperation,
    isAddModalOpen,
    setIsAddModalOpen,
    editingAddress,
    getPrimaryAddress,
    handleSetDefaultAddress,
    handleEditAddress,
    handleDeleteAddress,
    handleAddAddress,
    handleSaveAddress,
    isSaving: saveAddressMutation.isPending,
    saveError: saveAddressMutation.error,
    addAddress,
    validateAddress,
    isSettingPrimary: setPrimaryAddressMutation.isPending,
  };
}
